import requests
import time
from supabase import create_client, Client
import json
from typing import List, Dict, Optional

# Configurare Supabase
SUPABASE_URL = "https://ftjfabgifsbdlnbxvgwo.supabase.co"
SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZ0amZhYmdpZnNiZGxuYnh2Z3dvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU1MTAyOTcsImV4cCI6MjA3MTA4NjI5N30.os3bsl_sSyeLQ7O-cLGS2fUGlNzdtaxc_py_e0mjGQI"

supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)


class MALScraper:
    def __init__(self):
        self.base_url = "https://api.jikan.moe/v4"
        self.headers = {
            'User-Agent': 'AnimeRecommendationBot/1.0'
        }

    def get_top_anime(self, limit: int = 500, page: int = 25) -> List[Dict]:
        """Obține lista cu top anime de pe MAL"""
        try:
            url = f"{self.base_url}/top/anime"
            params = {
                'limit': min(limit, 25),  # API limit
                'page': page
            }

            response = requests.get(url, headers=self.headers, params=params)
            response.raise_for_status()

            time.sleep(1)  # Rate limiting
            return response.json().get('data', [])

        except Exception as e:
            print(f"Eroare la obținerea top anime: {e}")
            return []

    def get_anime_details(self, mal_id: int) -> Optional[Dict]:
        """Obține detaliile complete ale unui anime după MAL ID"""
        try:
            url = f"{self.base_url}/anime/{mal_id}/full"
            response = requests.get(url, headers=self.headers)
            response.raise_for_status()

            time.sleep(1)  # Rate limiting
            return response.json().get('data', {})

        except Exception as e:
            print(f"Eroare la obținerea detaliilor pentru anime {mal_id}: {e}")
            return None

    def get_anime_characters(self, anime_id: int) -> List[Dict]:
        """Obține caracterele unui anime"""
        try:
            url = f"{self.base_url}/anime/{anime_id}/characters"
            response = requests.get(url, headers=self.headers)
            response.raise_for_status()

            time.sleep(1)
            return response.json().get('data', [])

        except Exception as e:
            print(f"Eroare la obținerea caracterelor pentru anime {anime_id}: {e}")
            return []

    def extract_character_traits(self, character_name: str, role: str) -> str:
        """Extrage trăsăturile caracterului bazate pe nume și rol"""
        name_lower = character_name.lower()
        role_lower = role.lower()

        traits = []

        # Analiză bazată pe rol
        if 'main' in role_lower:
            traits.append('protagonist')
        elif 'supporting' in role_lower:
            traits.append('supporting')

        # Analiză bazată pe nume (pattern recognition simplu)
        if any(word in name_lower for word in ['dark', 'shadow', 'death', 'demon']):
            traits.append('villain')
        elif any(word in name_lower for word in ['light', 'hero', 'pure', 'angel']):
            traits.append('heroic')
        elif any(word in name_lower for word in ['smart', 'genius', 'wise']):
            traits.append('intelligent')
        elif any(word in name_lower for word in ['funny', 'comic', 'joke']):
            traits.append('comedic')

        if not traits:
            traits.append('normal')

        return ' '.join(traits)

    def get_main_characters_names(self, mal_anime_id: int) -> List[str]:
        """Obține numele caracterelor principale ale unui anime"""
        characters_data = self.get_anime_characters(mal_anime_id)
        main_characters = []

        # Filtrează doar caracterele principale
        for char_data in characters_data:
            role = char_data.get('role', '').lower()
            if 'main' in role:
                character = char_data.get('character', {})
                character_name = character.get('name', 'Unknown')
                main_characters.append(character_name)

                # Limităm la maxim 5 caractere principale
                if len(main_characters) >= 5:
                    break

        return main_characters

    def extract_studio_name(self, studios_data: List[Dict]) -> Optional[str]:
        """Extrage numele studioului principal"""
        if studios_data:
            return studios_data[0].get('name')
        return None

    def extract_demographic(self, demographics_data: List[Dict]) -> Optional[str]:
        """Extrage categoria demografică"""
        if demographics_data:
            return demographics_data[0].get('name')
        return None

    def find_anime_by_mal_id(self, anime_name: str) -> Optional[int]:
        """Găsește MAL ID-ul unui anime după nume folosind search API"""
        try:
            url = f"{self.base_url}/anime"
            params = {
                'q': anime_name,
                'limit': 1
            }
            
            response = requests.get(url, headers=self.headers, params=params)
            response.raise_for_status()
            
            time.sleep(1)
            data = response.json().get('data', [])
            
            if data:
                return data[0].get('mal_id')
                
        except Exception as e:
            print(f"Eroare la căutarea anime-ului {anime_name}: {e}")
        
        return None

    def update_existing_anime(self, anime_record: Dict) -> bool:
        """Actualizează un anime existent cu noile coloane"""
        try:
            anime_id = anime_record['id']
            anime_name = anime_record['name']
            
            print(f"🔄 Actualizez: {anime_name}")
            
            # Caută MAL ID-ul
            mal_id = self.find_anime_by_mal_id(anime_name)
            
            if not mal_id:
                print(f"  ❌ Nu am găsit MAL ID pentru: {anime_name}")
                return False
            
            # Obține detaliile complete
            anime_details = self.get_anime_details(mal_id)
            
            if not anime_details:
                print(f"  ❌ Nu am putut obține detaliile pentru: {anime_name}")
                return False
            
            # Extrage noile date
            synopsis = anime_details.get('synopsis', '')
            if synopsis:
                # Limitează synopsis la 1000 de caractere pentru a evita probleme de storage
                synopsis = synopsis[:1000] + '...' if len(synopsis) > 1000 else synopsis
            
            studio = self.extract_studio_name(anime_details.get('studios', []))
            demographic = self.extract_demographic(anime_details.get('demographics', []))
            
            # Pregătește update-ul
            update_data = {
                'synopsis': synopsis,
                'studio': studio,
                'demographic': demographic
            }
            
            # Actualizează în baza de date
            result = supabase.table('anime').update(update_data).eq('id', anime_id).execute()
            
            if result.data:
                print(f"  ✅ Actualizat cu succes!")
                print(f"    📝 Synopsis: {len(synopsis)} caractere")
                print(f"    🏢 Studio: {studio}")
                print(f"    👥 Demographic: {demographic}")
                return True
            else:
                print(f"  ❌ Eroare la actualizare în baza de date")
                return False
                
        except Exception as e:
            print(f"❌ Eroare la actualizarea anime-ului {anime_record.get('name', 'Unknown')}: {e}")
            return False

    def insert_anime(self, anime_data: Dict, mal_anime_id: int) -> Optional[int]:
        """Inserează un anime nou în baza de date (cu toate coloanele)"""
        try:
            # Obține detaliile complete
            anime_details = self.get_anime_details(mal_anime_id)
            main_characters = self.get_main_characters_names(mal_anime_id)

            # Extrage datele pentru noile coloane
            synopsis = ''
            studio = None
            demographic = None
            
            if anime_details:
                synopsis = anime_details.get('synopsis', '')
                if synopsis:
                    synopsis = synopsis[:1000] + '...' if len(synopsis) > 1000 else synopsis
                
                studio = self.extract_studio_name(anime_details.get('studios', []))
                demographic = self.extract_demographic(anime_details.get('demographics', []))

            # Pregătire date
            anime_record = {
                'name': anime_data.get('title', 'Unknown'),
                'episodes': anime_data.get('episodes') or 0,
                'themes': [theme['name'] for theme in anime_data.get('themes', [])],
                'genres': [genre['name'] for genre in anime_data.get('genres', [])],
                'mains': main_characters,
                'synopsis': synopsis,
                'studio': studio,
                'demographic': demographic
            }

            # Inserează în Supabase
            result = supabase.table('anime').insert(anime_record).execute()

            if result.data:
                print(f"✅ Anime insereat: {anime_record['name']}")
                print(f"  📝 Caractere principale: {', '.join(main_characters)}")
                print(f"  🏢 Studio: {studio}")
                print(f"  👥 Demographic: {demographic}")
                return result.data[0]['id']

        except Exception as e:
            print(f"❌ Eroare la inserarea anime: {e}")

        return None

    def update_existing_records(self, batch_size: int = 50):
        """Actualizează toate recordurile existente cu noile coloane"""
        print("🔄 Încep actualizarea recordurilor existente...")
        
        try:
            # Obține toate anime-urile care nu au synopsis completat
            result = supabase.table('anime')\
                .select('id, name')\
                .is_('synopsis', 'null')\
                .execute()
            
            anime_list = result.data
            total_anime = len(anime_list)
            
            print(f"📊 Găsite {total_anime} anime-uri de actualizat")
            
            updated_count = 0
            failed_count = 0
            
            for i, anime_record in enumerate(anime_list, 1):
                print(f"\n📊 Progres: {i}/{total_anime}")
                
                if self.update_existing_anime(anime_record):
                    updated_count += 1
                else:
                    failed_count += 1
                
                # Rate limiting
                time.sleep(2)
                
                # Pauză mai lungă la fiecare batch
                if i % batch_size == 0:
                    print(f"⏸️ Pauză după {i} anime-uri...")
                    time.sleep(10)
            
            print(f"\n🎉 Actualizare completă!")
            print(f"✅ Actualizate cu succes: {updated_count}")
            print(f"❌ Eșuate: {failed_count}")
            
        except Exception as e:
            print(f"❌ Eroare la actualizarea recordurilor: {e}")

    def scrape_and_populate(self, num_pages: int = 4):
        """Funcția principală pentru scraping și populare (anime-uri noi)"""
        print("🚀 Începe scraping-ul MyAnimeList pentru anime-uri noi...")

        total_anime = 0

        for page in range(1, num_pages + 1):
            print(f"\n📄 Procesez pagina {page}...")
            
            anime_list = self.get_top_anime(limit=25, page=page)

            for anime_data in anime_list:
                mal_id = anime_data.get('mal_id')
                title = anime_data.get('title', 'Unknown')

                print(f"\n🎯 Procesez: {title}")

                # Verifică dacă anime-ul există deja
                existing = supabase.table('anime').select('id').eq('name', title).execute()

                if existing.data:
                    print(f"  ⚠️ Anime-ul {title} există deja, sărim peste el")
                    continue

                # Inserează anime-ul cu toate coloanele
                anime_db_id = self.insert_anime(anime_data, mal_id)

                if anime_db_id:
                    total_anime += 1

                # Rate limiting
                time.sleep(2)

        print(f"\n🎉 Scraping complet! Total anime noi procesate: {total_anime}")


def main():
    # Verifică conexiunea la Supabase
    try:
        test = supabase.table('anime').select('count').execute()
        print("✅ Conexiunea la Supabase funcționează!")
    except Exception as e:
        print(f"❌ Eroare conexiune Supabase: {e}")
        print("Verifică SUPABASE_URL și SUPABASE_KEY")
        return

    # Inițializează scraper-ul
    scraper = MALScraper()

    # Alege ce vrei să faci
    print("\n🎯 Ce vrei să faci?")
    print("1. Actualizează anime-urile existente cu noile coloane")
    print("2. Adaugă anime-uri noi")
    print("3. Ambele (actualizează existente, apoi adaugă noi)")
    
    choice = input("\nIntroduci opțiunea (1/2/3): ").strip()
    
    if choice == "1":
        # Actualizează doar anime-urile existente
        scraper.update_existing_records()
        
    elif choice == "2":
        # Adaugă doar anime-uri noi
        scraper.scrape_and_populate(num_pages=200)
        
    elif choice == "3":
        # Ambele
        print("\n🔄 Primul pas: Actualizez anime-urile existente...")
        scraper.update_existing_records()
        
        print("\n🆕 Al doilea pas: Adaug anime-uri noi...")
        scraper.scrape_and_populate(num_pages=200)
        
    else:
        print("❌ Opțiune invalidă!")


if __name__ == "__main__":
    main()
